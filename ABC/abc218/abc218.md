# AtCoder Beginner Contest 218
2021-09-11(土) 21:00 ~ 2021-09-11(土) 22:40 (100分)

## A - Weather Forecast
https://atcoder.jp/contests/abc218/tasks/abc218_a

<details><summary>クリックで解説を開く</summary>

### キーワード
- 簡単な条件分岐(if文)
- 文字列の処理

</details>


## B - qwerty
https://atcoder.jp/contests/abc218/tasks/abc218_b

<details><summary>クリックで解説を開く</summary>

<br>

python3の `chr()` や `ord()` を使えるかどうか。

### キーワード
- 辞書順
- chr, ord

</details>


## C - Shapes
https://atcoder.jp/contests/abc218/tasks/abc218_c

<details><summary>クリックで解説を開く</summary>

<br>

実装がかなり面倒だった。<br>
自分の解法では、外周の `.` を削り、その後90度ごとに回転させて一致判定を行なっている。

</details>


## D - Rectangles
https://atcoder.jp/contests/abc218/tasks/abc218_d

<details><summary>クリックで解説を開く</summary>

<br>

長方形の左上と右下の点を決め、右上の点と左下の点が存在するかを求めます。<br>
"存在するか"を求めるときは、listを探索するのではなくset型(集合型)を探索する方がよかったですね。

同じ長方形を複数回カウントしないように、`x_i < x_j and y_i < y_j` という条件を入れています。

公式の解説にあった、二分探索を用いる解法を、"abc218_d 2.py"に示しました。

ほかにも解説で紹介されている別解がたくさんありますが、自分には理解できないものが多いので、Python3での実装例を紹介することはできません…。生成AIにコードを書いてもらったり、ほかの言語のコードをPython3に翻訳してもらうなどしてください。

</details>


## E - Destruction
https://atcoder.jp/contests/abc218/tasks/abc218_e

<details><summary>クリックで解説を開く</summary>

<br>

公式の解説の通り、まず全ての辺を取り除き、$`C_i > 0`$ の辺については報酬を得ておく。<br>
次に $`C_i`$ を辺の重みと捉えて最小全域木を求め、その最小全域木に含まれる辺の重みを引く。

"abc218_e 1.py"はクラスカル法で、"abc218_e 2.py"はプリム法で実装したもの。

### キーワード
- 連結無向グラフ
- 最小全域木(MST, Minimum Spanning Tree)
- クラスカル法 → Union-Find
- プリム法 → 優先度付きキュー(heapq)

</details>
