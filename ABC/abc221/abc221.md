# AtCoder Beginner Contest 221
2021-10-02(土) 21:00 ~ 2021-10-02(土) 22:40 (100分)

## A - Seismic magnitude scales
https://atcoder.jp/contests/abc221/tasks/abc221_a

<details><summary>クリックで解説を開く</summary>

<br>

求める値は $`32^{A-B}`$ です。
$`32 = 2^5`$ なので、$`32^{A-B} = 2 ^ {5(A-B)}`$ となります。<br>
また、`<<` を用いて1ビット左シフトすると、数字を2倍にすることができます。<br>
以上のことから、$`5(A-B)`$ シフト左シフトすればよいです。"abc221_a.py"を参照してください。

### キーワード
- 簡単な計算問題

</details>


## B - typo
https://atcoder.jp/contests/abc221/tasks/abc221_b

<details><summary>クリックで解説を開く</summary>

<br>

"abc221_b 1.py"は、swapをせずにスライスを用いることで、擬似的に `S` 内の文字を入れ替えています。<br>
"abc221_b 2.py"は、公式の解説にあった計算量 $`O(N)`$ 解法をPython3で実装したもの。

### キーワード
- 条件分岐(if文)
- 文字列の処理

</details>


## C - Select Mul
https://atcoder.jp/contests/abc221/tasks/abc221_c

<details><summary>クリックで解説を開く</summary>

<br>

$`N`$ に含まれる数字を振り分ける方法を全て調べ上げます。<br>
公式の解説にもありますが、計算量をより減らす工夫について解説します。

まずは、"leading zero を許容しても答えには影響しない"よりも先に、"分離後の2変数は数字列として見たときに単調非増加である"という部分を説明します。<br>
単調非増加というのを分かりやすく言うと、後ろに行っても数字が増加しない、すなわち、後ろに行っても数字は同じか減るだけ、ということです。<br>
同じ数字を使って数字を作るとき、大きい数字を上の位にした方が数字として大きくなるため、結果として積も大きくなるからです。

次に"leading zero を許容しても答えには影響しない"については先ほどの議論と同様で、先頭に0を持ってくるよりも後ろに持って行って、ほかの大きい数字を先頭に持ってきた方が数字が大きくなって積も大きくなるため、先頭に0がある場合は最適解にならない。だから先頭に0が来るような組み合わせを考えてしまっても最大値を求めるのには影響しない、ということになります。

"abc221_c.py"ではbit全探索を行なっています。
まずは `sorted(map(int, input()), reverse=True)` で、`N` を1文字ずつint型にし、降順にソートしています。<br>
`N` の1文字ずつをどちらの数字に割り振るか、をbit全探索するため、`i` を `1 << len(N)` まで動かします。`i >> j & 1` が0か1かで、`i` 文字目をどちらの数字に割り振るかを決めています。少し工夫して、この数字をindexとして使っています。

### キーワード
- 想定解は順列全探索っぽい(?)
- bit全探索

</details>


## D - Online games
https://atcoder.jp/contests/abc221/tasks/abc221_d

<details><summary>クリックで解説を開く</summary>

### キーワード
- いもす法(応用)(?)

### 類題
- "AtCoder Beginner Contest 188" > "[D - Snuke Prime](https://atcoder.jp/contests/abc188/tasks/abc188_d)"

</details>
